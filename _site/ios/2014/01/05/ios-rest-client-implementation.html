<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	<title>无网不剩</title>
	<link rel="stylesheet" type="text/css" href="/css/style.css" />
	<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	<link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/lzyy">
	<script type="text/javascript">
	  var _gaq = _gaq || [];
	  _gaq.push(['_setAccount', 'UA-1281124-20']);
	  _gaq.push(['_trackPageview']);

	  (function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	  })();
	</script>
</head>

	<body>
		<div id="logo">
			<span id="tags">保持好奇</span>
			<h1><a href="/">Bilinguis | 阿丹</a></h1></div>
		<div id="wrapper">
			<div id="content">
				<a target="_blank" style="float:right;margin-top:15px" href="http://twitter.com/share?url=http://blog.leezhong.com/ios/2014/01/05/ios-rest-client-implementation.html&via=lzyy&text=基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client"><span class="balloon">retweet</span></a>
				<h2>基于AFNetworking2.0和ReactiveCocoa2.1的iOS REST Client</h2>
				<div class="cnt">
					<p>在开发iOS App时经常会遇到跟后端REST API通信的情况。这就涉及到错误处理，NSDictionary与Model的映射，用户登录与登出，权限验证，Archive/UnArchive，Copy，AccessToken过期处理等等，如果没有很好地处理这些点，就容易出现代码复杂度增大，结构散乱，不方便后期维护的现象。</p>

<p>正好最近在看AFNetworking2.0和ReactiveCocoa2.1，参考了github的<a href="https://github.com/octokit/octokit.objc">octokit</a>，重写了花瓣的iOS REST API，分享些心得。</p>

<h3>基本结构</h3>

<div class="highlight"><pre><code class="objc"><span class="o">|-</span> <span class="n">HBPAPI</span><span class="p">.</span><span class="n">h</span>
<span class="o">|-</span> <span class="n">Classes</span>
    <span class="o">|-</span> <span class="n">HBPAPIManager</span><span class="p">.</span><span class="n">h</span>
    <span class="o">|-</span> <span class="n">HBPAPIManager</span><span class="p">.</span><span class="n">m</span>
    <span class="o">|-</span> <span class="n">Models</span>
        <span class="o">|-</span> <span class="n">HBPObject</span><span class="p">.</span><span class="n">h</span>
        <span class="o">|-</span> <span class="n">HBPObject</span><span class="p">.</span><span class="n">m</span>
        <span class="o">|-</span> <span class="n">HBPUser</span><span class="p">.</span><span class="n">h</span>
        <span class="o">|-</span> <span class="n">HBPUser</span><span class="p">.</span><span class="n">m</span>
        <span class="p">...</span>
</code></pre></div>


<p>使用时，直接引用<code>HBPAPI.h</code>即可，里面包含了所有的Class。因为使用了AFNetworking2.0，所以不再是HBPClient，而是HBPManager。 HBPAPIManager包含了所有的跟服务端通信的方法，通过Category来区分。</p>

<div class="highlight"><pre><code class="objc"><span class="cp">#pragma mark - HBPAPIManager (Private)</span>

<span class="k">@interface</span> <span class="nc">HBPAPIManager</span> <span class="nl">(Private)</span>

<span class="c1">// 内部统一使用这个方法来向服务端发送请求</span>
<span class="c1">//</span>
<span class="c1">// resultClass - 从服务端获取到JSON数据后，使用哪个Class来将JSON转换为OC的Model</span>
<span class="c1">// listKey - 如果不指定，表示返回的是一个object，如user，如果指定表示返回的是一个数组，listKey就表示这个列表的keyname，如{&#39;users&#39;:[]}, 那么listName就为&#39;user&#39;</span>
<span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">requestWithMethod:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">method</span> <span class="nf">relativePath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">relativePath</span> <span class="nf">parameters:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">parameters</span> <span class="nf">resultClass:</span><span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="nv">resultClass</span> <span class="nf">listKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">listKey</span><span class="p">;</span>
<span class="k">@end</span>


<span class="cp">#pragma mark - HBPAPIManager (User)</span>

<span class="k">@interface</span> <span class="nc">HBPAPIManager</span> <span class="nl">(User)</span>

<span class="c1">// signal会send user，如果没有user，就会sendError</span>
<span class="c1">// 必须当前用户已经登录的情况下调用</span>
<span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">fetchUserInfo</span><span class="p">;</span>

<span class="c1">// ...</span>
<span class="k">@end</span>


<span class="cp">#pragma mark - HBPAPIManager (Friendship)</span>
<span class="c1">// ...</span>
</code></pre></div>


<p>Models Group包含了所有跟服务端API对应的Model，比如<code>HBPComment</code></p>

<p>HBPComment.h</p>

<div class="highlight"><pre><code class="objc"><span class="cp">#import &quot;HBPObject.h&quot;</span>

<span class="k">@class</span> <span class="nc">HBPUser</span>;

<span class="k">@interface</span> <span class="nc">HBPComment</span> : <span class="nc">HBPObject</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">assign</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">commentID</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">createdAt</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">HBPUser</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>
<span class="c1">//...</span>
<span class="k">@end</span>
</code></pre></div>


<p>HBPComment.m</p>

<div class="highlight"><pre><code class="objc"><span class="cp">#import &quot;HBPComment.h&quot;</span>

<span class="k">@implementation</span> <span class="nc">HBPComment</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">JSONKeysToPropertyKeys</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">@{</span>
             <span class="s">@&quot;comment_id&quot;</span><span class="o">:</span> <span class="s">@&quot;commentID&quot;</span><span class="p">,</span>
             <span class="s">@&quot;user_id&quot;</span><span class="o">:</span> <span class="s">@&quot;userID&quot;</span><span class="p">,</span>
             <span class="s">@&quot;created_at&quot;</span><span class="o">:</span> <span class="s">@&quot;createdAt&quot;</span><span class="p">,</span>
             <span class="c1">//...</span>
             <span class="p">};</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div>


<h3>Archive / UnArchive / Copy</h3>

<p>每一个Object都要支持Archive / UnArchive / Copy，也就是要实现<code>&lt;NSCoding&gt;</code>和<code>&lt;NSCopying&gt;</code>协议，这两个协议的内容其实就是对Object的Property做些处理，所以如果可以在基类里把这些事都统一处理，就会方便许多。octokit使用<a href="https://github.com/MantleFramework/Mantle">Mantle</a>来做这些事情，不过我觉得Mantle还是有些麻烦，于是写了个通过运行时来获取property，并实现<code>&lt;NSCoding&gt;</code> 和 <code>&lt;NSCopying&gt;</code>的基类，只有两个公共方法：</p>

<div class="highlight"><pre><code class="objc"><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="k">@interface</span> <span class="nc">HBPObject</span> : <span class="nc">NSObject</span> <span class="o">&lt;</span><span class="n">NSCopying</span><span class="p">,</span> <span class="n">NSCoding</span><span class="o">&gt;</span>

<span class="c1">// 解析API返回的JSON，返回对应的Model</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">initWithDictionary</span><span class="o">:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">JSON</span><span class="p">;</span>

<span class="c1">// JSON key到property的映射关系</span>
<span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">JSONKeysToPropertyKeys</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div>


<p>其中<code>- (id)initWithDictionary:(NSDictionary *)JSON</code>的作用是遍历Object的Property，如果Property的Class是<code>HBPObject</code>，那么就调用<code>- (id)initWithDictionary:(NSDictionary *)JSO</code>，不然就通过KVC的<code>setValue:forKey:</code>来设定值。</p>

<p><code>- (NSDictionary *)JSONKeysToPropertyKeys</code>的内容大概是这样：</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">JSONKeysToPropertyKeys</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">@{</span>
             <span class="s">@&quot;id&quot;</span><span class="o">:</span> <span class="s">@&quot;ID&quot;</span><span class="p">,</span>
             <span class="s">@&quot;nav_link&quot;</span><span class="o">:</span> <span class="s">@&quot;navLink&quot;</span><span class="p">,</span>
             <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>


<p>这样通过一个<code>HBPObject</code>基类就完成了 Archive / UnArchive / Copy 。</p>

<h3>用户的登录与登出</h3>

<p>先来说说登录，由于使用RAC，在构造API时，就不需要传入Block了，随之而来的一个问题就是需要在注释中说明<code>sendNext</code>时会发送什么内容。</p>

<div class="highlight"><pre><code class="objc"><span class="k">+</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">signInUsingUsername:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">username</span> <span class="nf">passowrd:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">password</span>
<span class="p">{</span>
    <span class="n">NSAssert</span><span class="p">(</span><span class="n">API_CLIENT_ID</span> <span class="o">&amp;&amp;</span> <span class="n">API_CLIENT_SECRET</span><span class="p">,</span> <span class="s">@&quot;API_CLIENT_ID and API_CLIENT_SECRET must be setted&quot;</span><span class="p">);</span>
    <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">@{</span>
                                 <span class="s">@&quot;grant_type&quot;</span><span class="o">:</span> <span class="s">@&quot;password&quot;</span><span class="p">,</span>
                                 <span class="s">@&quot;username&quot;</span><span class="o">:</span> <span class="n">username</span><span class="p">,</span>
                                 <span class="s">@&quot;password&quot;</span><span class="o">:</span> <span class="n">password</span><span class="p">,</span>
                                 <span class="p">};</span>
    <span class="n">HBPAPIManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">createManager</span><span class="p">];</span>
    
    <span class="k">return</span> <span class="p">[[</span><span class="n">manager</span> <span class="n">fetchTokenWithParameters</span><span class="o">:</span><span class="n">parameters</span><span class="p">]</span>
            <span class="nl">setNameWithFormat:</span><span class="s">@&quot;+signInUsingUsername:%@ password:%@&quot;</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>


<p>看着还挺简单的吧，因为主要工作都是<code>+fetchMoreData:parameters</code>在做，看看它的实现</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">fetchTokenWithParameters:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">parameters</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[[[[[[</span><span class="n">self</span> <span class="n">rac_POST</span><span class="o">:</span><span class="s">@&quot;oauth/access_token&quot;</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span><span class="p">]</span>
             <span class="c1">// reduceEach的作用是传入多个参数，返回单个参数，是基于`map`的一种实现</span>
             <span class="nl">reduceEach:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">response</span><span class="p">){</span>
                 <span class="c1">// 拿到token后，就设置token property</span>
                 <span class="c1">// setToken:方法会被触发，在那里会设置请求的头信息，如Authorization。</span>
                 <span class="n">HBPAccessToken</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HBPAccessToken</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithDictionary</span><span class="o">:</span><span class="n">response</span><span class="p">];</span>
                 <span class="n">self</span><span class="p">.</span><span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="p">;</span>
                 <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
             <span class="p">}]</span>
             <span class="nl">catch:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                 <span class="c1">// 对Error进行处理，方便外部识别</span>
                 <span class="n">NSInteger</span> <span class="n">code</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1001</span> <span class="o">?</span> <span class="n">HBPAPIManagerErrorConnectionFailed</span> <span class="o">:</span> <span class="n">HBPAPIManagerErrorAuthenticatedFailed</span><span class="p">;</span>
                 <span class="n">NSError</span> <span class="o">*</span><span class="n">apiError</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSError</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithDomain</span><span class="o">:</span><span class="n">HBPAPIManagerErrorDomain</span> <span class="n">code</span><span class="o">:</span><span class="n">code</span> <span class="n">userInfo</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
                 <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="n">error</span><span class="o">:</span><span class="n">apiError</span><span class="p">];</span>
             <span class="p">}]</span>
             <span class="nl">then:</span><span class="o">^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">{</span>
                 <span class="c1">// 一切正常的话，顺便获取用户信息</span>
                 <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">fetchUserInfo</span><span class="p">];</span>
             <span class="p">}]</span>
             <span class="nl">doNext:</span><span class="o">^</span><span class="p">(</span><span class="n">HBPUser</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
                 <span class="c1">// doNext相当于一个钩子，是在sendNext时会被执行的一段代码</span>
                 <span class="n">self</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span><span class="p">;</span>
             <span class="p">}]</span>
             <span class="c1">// 把发送内容换成self</span>
             <span class="nl">mapReplace:</span><span class="n">self</span><span class="p">]</span>
             <span class="c1">// 避免side effect</span>
             <span class="n">replayLazily</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>


<p>这里对signal进行了chain / modify / hook 等操作，主要作用是获取access token和用户信息。</p>

<p>用户的登出就简单了，直接设置<code>user</code>和<code>token</code>为<code>nil</code>就行了。</p>

<h3>设置超时时间和缓存策略</h3>

<p>因为AF2.0使用了新的架构，导致要设置Request的超时和缓存稍微有些麻烦，需要新建一个继承自<code>AFHTTPRequestSerializer</code>的Class</p>

<div class="highlight"><pre><code class="objc"><span class="k">@interface</span> <span class="nc">HBPAPIRequestSerializer</span> : <span class="nc">AFHTTPRequestSerializer</span> <span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">HBPAPIRequestSerializer</span>

<span class="k">-</span> <span class="p">(</span><span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="p">)</span><span class="nf">requestWithMethod:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">method</span> <span class="nf">URLString:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">URLString</span> <span class="nf">parameters:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">parameters</span>
<span class="p">{</span>
    <span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">requestWithMethod</span><span class="o">:</span><span class="n">method</span> <span class="n">URLString</span><span class="o">:</span><span class="n">URLString</span> <span class="n">parameters</span><span class="o">:</span><span class="n">parameters</span><span class="p">];</span>
    <span class="n">request</span><span class="p">.</span><span class="n">timeoutInterval</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">request</span><span class="p">.</span><span class="n">cachePolicy</span> <span class="o">=</span> <span class="n">NSURLRequestReloadIgnoringLocalCacheData</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">request</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div>


<p>然后将这个class设置为manager.requestSerializer</p>

<div class="highlight"><pre><code class="objc"><span class="n">HBPAPIManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HBPAPIManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithBaseURL</span><span class="o">:</span><span class="p">[</span><span class="n">NSURL</span> <span class="n">URLWithString</span><span class="o">:</span><span class="n">API_SERVER</span><span class="p">]];</span>
<span class="n">manager</span><span class="p">.</span><span class="n">requestSerializer</span> <span class="o">=</span> <span class="p">[</span><span class="n">HBPAPIRequestSerializer</span> <span class="n">serializer</span><span class="p">];</span>
</code></pre></div>


<p>这样就行了</p>

<h3>权限验证</h3>

<p>这个比较简单些，直接在方法里面加上判断</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">createCommentWithPinID:</span><span class="p">(</span><span class="n">NSInteger</span><span class="p">)</span><span class="nv">pinID</span> <span class="nf">text:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">isAuthenticated</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="n">error</span><span class="o">:</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">class</span> <span class="n">authenticatedError</span><span class="p">]];</span>
 
    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="n">requestWithMethod</span><span class="o">:</span><span class="s">@&quot;POST&quot;</span> <span class="n">relativePath</span><span class="o">:</span><span class="p">[</span><span class="n">NSString</span> <span class="n">stringWithFormat</span><span class="o">:</span><span class="s">@&quot;pins/%d/comments&quot;</span><span class="p">,</span> <span class="n">pinID</span><span class="p">]</span> <span class="n">parameters</span><span class="o">:</span><span class="p">@{</span><span class="s">@&quot;text&quot;</span><span class="o">:</span> <span class="n">text</span><span class="p">}</span> <span class="n">resultClass</span><span class="o">:</span><span class="p">[</span><span class="n">HBPComment</span> <span class="n">class</span><span class="p">]</span> <span class="n">listKey</span><span class="o">:</span><span class="s">@&quot;comment&quot;</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>


<h3>AccessToken过期的处理</h3>

<p>AccessToken过期和获取新的AccessToken可以交给使用者来做，但是会比较麻烦，最好的方法是过期后自动去获取新的AccessToken，拿到Token后自动去执行之前失败的请求，这块我是这么处理的</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">requestWithMethod:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">method</span> <span class="nf">relativePath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">relativePath</span> <span class="nf">parameters:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">parameters</span> <span class="nf">resultClass:</span><span class="p">(</span><span class="kt">Class</span><span class="p">)</span><span class="nv">resultClass</span> <span class="nf">listKey:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">listKey</span>
<span class="p">{</span>
    <span class="n">RACSignal</span> <span class="o">*</span><span class="n">requestSignal</span><span class="p">;</span>
    <span class="c1">// create requestSignal</span>
    <span class="c1">// ...</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">requestSignal</span> <span class="n">catch</span><span class="o">:^</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">HBPAPIManagerErrorInvalidAccessToken</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">[[[</span><span class="n">self</span> <span class="n">refreshToken</span><span class="p">]</span> <span class="n">ignoreValues</span><span class="p">]</span> <span class="n">concat</span><span class="o">:</span><span class="n">requestSignal</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="n">error</span><span class="o">:</span><span class="n">error</span><span class="p">];</span>
    <span class="p">}];</span>
<span class="p">}</span>
</code></pre></div>


<h3>HBPObject SubClass</h3>

<p>那些继承自<code>HBPObject</code>的子类，有些事情是<code>HBPObject</code>无法处理的，比如NSArray的Property，因为Objective-C不支持generic，所以无法知道这个数组包含的究竟是怎样的Class，这时就需要在子类对这些property做处理。</p>

<p>比如画板(HBPBoard)有一个叫<code>pins</code>的NSArray属性，因为在<code>HBPObject</code>中使用了KVC，所以如果子类有类似<code>setXXX:</code>的方法的话，那么该方法就会被调用，利用这一点，就可以处理那些特殊情况。</p>

<div class="highlight"><pre><code class="objc"><span class="k">@implementation</span> <span class="nc">HBPBoard</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setPins:</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">pins</span>
<span class="p">{</span>
    <span class="n">_pins</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pins</span><span class="p">.</span><span class="n">rac_sequence</span> <span class="n">map</span><span class="o">:^</span><span class="kt">id</span><span class="p">(</span><span class="kt">id</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">HBPPin</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithDictionary</span><span class="o">:</span><span class="n">value</span><span class="p">];</span>
    <span class="p">}]</span> <span class="n">array</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>
</code></pre></div>


<p>再比如，返回的JSON内容中，有一个叫<code>content</code>的key，其中有type / date / color 等sub key，而你只想要<code>type</code>信息，只需添加一个<code>type</code> property，然后在<code>setContent</code>时，设置一下<code>type</code>即可。</p>

<div class="highlight"><pre><code class="objc"><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setContent:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">content</span>
<span class="p">{</span>
    <span class="n">_type</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="s">@&quot;type&quot;</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>


<hr />

<p>以上就是我在使用AFNetworking2.0和ReactiveCocoa2.1构建iOS REST Client时的一些小心得，确实能感觉到RAC带了不少方便，虽然也同时带来了一些弊端（如返回的内容不明确，学习成本高），但还是利大于弊。</p>

<p>有什么问题和想法，欢迎交流。</p>

					<br />
					--EOF--
					<p>若无特别说明，本站文章均为原创，转载请保留链接，谢谢</p>
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  /**
					* var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread] 
					*/
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://lzyyblog.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
			<div id="footer">
	<div id="feed">
		<div class="badget" id="github">
			<a href="http://github.com/lzyy">
			<span class="service">github</span>
			<span class="info">200+</span>
			</a>
		</div>
		<div class="badget" id="twt">
			<a href="http://twitter.com/lzyy">
			<span class="service">twitter</span>
			<span class="info">800+</span>
			</a>
		</div>
		<div class="badget" id="feedburner">
			<a href="http://feeds.feedburner.com/lzyy">
			<span class="service">rss</span>
			<span class="info">1000+</span>
			</a>
		</div>
	</div>
	<span style="color:#bbb;font-size:12px">make the world a little better and easier</span>
	<p style="clear:both"></p>
</div>


		</div>
	</body>
</html>

